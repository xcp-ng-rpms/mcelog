The patches were in the process of being committed to Andi's upstream mcelog
tree when they were applied to the RHEL source.  The patch subjects are

	Add better decoding support for Haswell server processors
	More compact data structures for reporting SNB/IVB memory controller errors

and were provided early by Tony Luck @ Intel.

diff -urNp mcelog-d2e13bf0.orig/haswell.c mcelog-d2e13bf0/haswell.c
--- mcelog-d2e13bf0.orig/haswell.c	1969-12-31 19:00:00.000000000 -0500
+++ mcelog-d2e13bf0/haswell.c	2014-09-08 09:59:52.998327718 -0400
@@ -0,0 +1,150 @@
+/* Copyright (C) 2013 Intel Corporation
+   Decode Intel Ivy Bridge specific machine check errors.
+
+   mcelog is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; version
+   2.
+
+   mcelog is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should find a copy of v2 of the GNU General Public License somewhere
+   on your Linux system; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+   Author: Tony Luck
+*/
+
+#include "mcelog.h"
+#include "bitfield.h"
+#include "haswell.h"
+#include "memdb.h"
+
+/* See IA32 SDM Vol3B Table 16-20 */
+
+static char *pcu_1[] = {
+	[0x00] = "No Error",
+	[0x09] = "MC_MESSAGE_CHANNEL_TIMEOUT",
+	[0x0D] = "MC_IMC_FORCE_SR_S3_TIMEOUT",
+	[0x0E] = "MC_CPD_UNCPD_SD_TIMEOUT",
+	[0x13] = "MC_DMI_TRAINING_TIMEOUT",
+	[0x15] = "MC_DMI_CPU_RESET_ACK_TIMEOUT",
+	[0x1E] = "MC_VR_ICC_MAX_LT_FUSED_ICC_MAX",
+	[0x25] = "MC_SVID_COMMAN_TIMEOUT",
+	[0x29] = "MC_VR_VOUT_MAC_LT_FUSED_SVID",
+	[0x2B] = "MC_PKGC_WATCHDOG_HANG_CBZ_DOWN",
+	[0x2C] = "MC_PKGC_WATCHDOG_HANG_CBZ_UP",
+	[0x39] = "MC_PKGC_WATCHDOG_HANG_C3_UP_SF",
+	[0x44] = "MC_CRITICAL_VR_FAILED",
+	[0x45] = "MC_ICC_MAX_NOTSUPPORTED",
+	[0x46] = "MC_VID_RAMP_DOWN_FAILED",
+	[0x47] = "MC_EXCL_MODE_NO_PMREQ_CMP",
+	[0x48] = "MC_SVID_READ_REG_ICC_MAX_FAILED",
+	[0x49] = "MC_SVID_WRITE_REG_VOUT_MAX_FAILED",
+	[0x4B] = "MC_BOOT_VID_TIMEOUT_DRAM_0",
+	[0x4C] = "MC_BOOT_VID_TIMEOUT_DRAM_1",
+	[0x4D] = "MC_BOOT_VID_TIMEOUT_DRAM_2",
+	[0x4E] = "MC_BOOT_VID_TIMEOUT_DRAM_3",
+	[0x4F] = "MC_SVID_COMMAND_ERROR",
+	[0x52] = "MC_FIVR_CATAS_OVERVOL_FAULT",
+	[0x53] = "MC_FIVR_CATAS_OVERCUR_FAULT",
+	[0x57] = "MC_SVID_PKGC_REQUEST_FAILED",
+	[0x58] = "MC_SVID_IMON_REQUEST_FAILED",
+	[0x59] = "MC_SVID_ALERT_REQUEST_FAILED",
+	[0x60] = "MC_INVALID_PKGS_REQ_PCH",
+	[0x61] = "MC_INVALID_PKGS_REQ_QPI",
+	[0x62] = "MC_INVALID_PKGS_RSP_QPI",
+	[0x63] = "MC_INVALID_PKGS_RSP_PCH",
+	[0x64] = "MC_INVALID_PKG_STATE_CONFIG",
+	[0x67] = "MC_HA_IMC_RW_BLOCK_ACK_TIMEOUT",
+	[0x68] = "MC_IMC_RW_SMBUS_TIMEOUT",
+	[0x69] = "MC_HA_FAILSTS_CHANGE_DETECTED",
+	[0x6A] = "MC_MSGCH_PMREQ_CMP_TIMEOUT",
+	[0x70] = "MC_WATCHDOG_TIMEOUT_PKGC_SLAVE",
+	[0x71] = "MC_WATCHDOG_TIMEOUT_PKGC_MASTER",
+	[0x72] = "MC_WATCHDOG_TIMEOUT_PKGS_MASTER",
+	[0x7C] = "MC_BIOS_RST_CPL_INVALID_SEQ",
+	[0x7D] = "MC_MORE_THAN_ONE_TXT_AGENT",
+	[0x81] = "MC_RECOVERABLE_DIE_THERMAL_TOO_HOT"
+};
+
+static struct field pcu_mc4[] = {
+	FIELD(24, pcu_1),
+	{}
+};
+
+/* See IA32 SDM Vol3B Table 16-21 */
+
+static char *qpi[] = {
+	[0x02] = "Intel QPI physical layer detected drift buffer alarm",
+	[0x03] = "Intel QPI physical layer detected latency buffer rollover",
+	[0x10] = "Intel QPI link layer detected control error from R3QPI",
+	[0x11] = "Rx entered LLR abort state on CRC error",
+	[0x12] = "Unsupported or undefined packet",
+	[0x13] = "Intel QPI link layer control error",
+	[0x15] = "RBT used un-initialized value",
+	[0x20] = "Intel QPI physical layer detected a QPI in-band reset but aborted initialization",
+	[0x21] = "Link failover data self healing",
+	[0x22] = "Phy detected in-band reset (no width change)",
+	[0x23] = "Link failover clock failover",
+	[0x30] = "Rx detected CRC error - successful LLR after Phy re-init",
+	[0x31] = "Rx detected CRC error - successful LLR wihout Phy re-init",
+};
+
+static struct field qpi_mc[] = {
+	FIELD(16, qpi),
+	{}
+};
+
+/* See IA32 SDM Vol3B Table 16-22 */
+
+static struct field memctrl_mc9[] = {
+	SBITFIELD(16, "DDR3 address parity error"),
+	SBITFIELD(17, "Uncorrected HA write data error"),
+	SBITFIELD(18, "Uncorrected HA data byte enable error"),
+	SBITFIELD(19, "Corrected patrol scrub error"),
+	SBITFIELD(20, "Uncorrected patrol scrub error"),
+	SBITFIELD(21, "Corrected spare error"),
+	SBITFIELD(22, "Uncorrected spare error"),
+	SBITFIELD(23, "Corrected memory read error"),
+	SBITFIELD(24, "iMC write data buffer parity error"),
+	SBITFIELD(25, "DDR4 command address parity error"),
+	{}
+};
+
+void hsw_decode_model(int cputype, int bank, u64 status, u64 misc)
+{
+	switch (bank) {
+	case 4:
+		Wprintf("PCU: ");
+		switch (EXTRACT(status, 0, 15) & ~(1ull << 12)) {
+		case 0x402: case 0x403:
+			Wprintf("Internal errors ");
+			break;
+		case 0x406:
+			Wprintf("Intel TXT errors ");
+			break;
+		case 0x407:
+			Wprintf("Other UBOX Internal errors ");
+			break;
+		}
+		if (EXTRACT(status, 16, 19))
+			Wprintf("PCU internal error ");
+		decode_bitfield(status, pcu_mc4);
+		break;
+	case 5:
+	case 20:
+	case 21:
+		Wprintf("QPI: ");
+		decode_bitfield(status, qpi_mc);
+		break;
+	case 9: case 10: case 11: case 12:
+	case 13: case 14: case 15: case 16:
+		Wprintf("MemCtrl: ");
+		decode_bitfield(status, memctrl_mc9);
+		break;
+	}
+}
diff -urNp mcelog-d2e13bf0.orig/haswell.h mcelog-d2e13bf0/haswell.h
--- mcelog-d2e13bf0.orig/haswell.h	1969-12-31 19:00:00.000000000 -0500
+++ mcelog-d2e13bf0/haswell.h	2014-09-08 09:59:52.998327718 -0400
@@ -0,0 +1,2 @@
+void hsw_decode_model(int cputype, int bank, u64 status, u64 misc);
+void haswell_ep_memerr_misc(struct mce *m, int *channel, int *dimm);
diff -urNp mcelog-d2e13bf0.orig/intel.c mcelog-d2e13bf0/intel.c
--- mcelog-d2e13bf0.orig/intel.c	2014-09-08 09:59:39.622699389 -0400
+++ mcelog-d2e13bf0/intel.c	2014-09-08 09:59:52.998327718 -0400
@@ -24,6 +24,7 @@
 #include "page.h"
 #include "sandy-bridge.h"
 #include "ivy-bridge.h"
+#include "haswell.h"
 #include "xeon75xx.h"
 
 int memory_error_support;
@@ -33,7 +34,7 @@ void intel_cpu_init(enum cputype cpu)
 	if (cpu == CPU_NEHALEM || cpu == CPU_XEON75XX || cpu == CPU_INTEL ||
 	    cpu == CPU_SANDY_BRIDGE || cpu == CPU_SANDY_BRIDGE_EP ||
 	    cpu == CPU_IVY_BRIDGE || cpu == CPU_IVY_BRIDGE_EPEX ||
-	    cpu == CPU_HASWELL)
+	    cpu == CPU_HASWELL || cpu == CPU_HASWELL_EPEX)
 		memory_error_support = 1;
 }
 
@@ -67,9 +68,10 @@ enum cputype select_intel_cputype(int fa
 			return CPU_IVY_BRIDGE;
 		else if (model == 0x3e)
 			return CPU_IVY_BRIDGE_EPEX;
-		else if (model == 0x3c || model == 0x3f || model == 0x45 ||
-			 model == 0x46)
+		else if (model == 0x3c || model == 0x45 || model == 0x46)
 			return CPU_HASWELL;
+		else if (model == 0x3f)
+			return CPU_HASWELL_EPEX;
 		if (model > 0x1a) {
 			Eprintf("Family 6 Model %x CPU: only decoding architectural errors\n",
 				model);
diff -urNp mcelog-d2e13bf0.orig/intel.h mcelog-d2e13bf0/intel.h
--- mcelog-d2e13bf0.orig/intel.h	2014-09-08 09:59:39.621699344 -0400
+++ mcelog-d2e13bf0/intel.h	2014-09-08 09:59:52.998327718 -0400
@@ -18,5 +18,6 @@ extern int memory_error_support;
 	case CPU_SANDY_BRIDGE: \
 	case CPU_IVY_BRIDGE: \
 	case CPU_IVY_BRIDGE_EPEX: \
-	case CPU_HASWELL
+	case CPU_HASWELL: \
+	case CPU_HASWELL_EPEX
 
diff -urNp mcelog-d2e13bf0.orig/ivy-bridge.c mcelog-d2e13bf0/ivy-bridge.c
--- mcelog-d2e13bf0.orig/ivy-bridge.c	2014-09-08 09:59:39.621699344 -0400
+++ mcelog-d2e13bf0/ivy-bridge.c	2014-09-08 09:59:56.033470497 -0400
@@ -68,20 +68,16 @@ static struct field pcu_mc4[] = {
 
 /* See IA32 SDM Vol3B Table 16-18 */
 
-static char *memctrl_1[] = {
-	[0x001] = "Address parity error",
-	[0x002] = "HA Wrt buffer Data parity error",
-	[0x004] = "HA Wrt byte enable parity error",
-	[0x008] = "Corrected patrol scrub error",
-	[0x010] = "Uncorrected patrol scrub error",
-	[0x020] = "Corrected spare error",
-	[0x040] = "Uncorrected spare error",
-	[0x080] = "Corrected memory read error",
-	[0x100] = "iMC, WDB, parity errors",
-};
-
 static struct field memctrl_mc9[] = {
-	FIELD(16, memctrl_1),
+	SBITFIELD(16, "Address parity error"),
+	SBITFIELD(17, "HA Wrt buffer Data parity error"),
+	SBITFIELD(18, "HA Wrt byte enable parity error"),
+	SBITFIELD(19, "Corrected patrol scrub error"),
+	SBITFIELD(20, "Uncorrected patrol scrub error"),
+	SBITFIELD(21, "Corrected spare error"),
+	SBITFIELD(22, "Uncorrected spare error"),
+	SBITFIELD(23, "Corrected memory read error"),
+	SBITFIELD(24, "iMC, WDB, parity errors"),
 	{}
 };
 
diff -urNp mcelog-d2e13bf0.orig/Makefile mcelog-d2e13bf0/Makefile
--- mcelog-d2e13bf0.orig/Makefile	2014-09-08 09:59:39.610698703 -0400
+++ mcelog-d2e13bf0/Makefile	2014-09-08 09:59:52.998327718 -0400
@@ -32,7 +32,7 @@ OBJ := p4.o k8.o mcelog.o dmi.o tsc.o co
        nehalem.o dunnington.o tulsa.o config.o memutil.o msg.o   \
        eventloop.o leaky-bucket.o memdb.o server.o trigger.o 	 \
        client.o cache.o sysfs.o yellow.o page.o rbtree.o 	 \
-       xeon75xx.o sandy-bridge.o ivy-bridge.o msr.o
+       xeon75xx.o sandy-bridge.o ivy-bridge.o haswell.o msr.o
 DISKDB_OBJ := diskdb.o dimm.o db.o
 CLEAN := mcelog dmi tsc dbquery .depend .depend.X dbquery.o ${DISKDB_OBJ}
 DOC := mce.pdf
diff -urNp mcelog-d2e13bf0.orig/mcelog.c mcelog-d2e13bf0/mcelog.c
--- mcelog-d2e13bf0.orig/mcelog.c	2014-09-08 09:59:39.622699389 -0400
+++ mcelog-d2e13bf0/mcelog.c	2014-09-08 09:59:52.999327768 -0400
@@ -228,6 +228,7 @@ static char *cputype_name[] = {
 	[CPU_IVY_BRIDGE] = "Ivy Bridge", /* Fill in better name */
 	[CPU_IVY_BRIDGE_EPEX] = "Ivy Bridge EP/EX", /* Fill in better name */
 	[CPU_HASWELL] = "Haswell", /* Fill in better name */
+	[CPU_HASWELL_EPEX] = "Haswell EP/EX", /* Fill in better name */
 };
 
 static struct config_choice cpu_choices[] = {
@@ -264,6 +265,8 @@ static struct config_choice cpu_choices[
 	{ "ivybridge-ep", CPU_IVY_BRIDGE_EPEX }, /* Fill in better name */
 	{ "ivybridge-ex", CPU_IVY_BRIDGE_EPEX }, /* Fill in better name */
 	{ "haswell", CPU_HASWELL }, /* Fill in better name */
+	{ "haswell-ep", CPU_HASWELL_EPEX }, /* Fill in better name */
+	{ "haswell-ex", CPU_HASWELL_EPEX }, /* Fill in better name */
 	{}
 };
 
@@ -424,7 +427,8 @@ static void dump_mce(struct mce *m, unsi
 			fam,
 			mod);
 	}
-	if (cputype != CPU_SANDY_BRIDGE_EP && cputype != CPU_IVY_BRIDGE_EPEX)
+	if (cputype != CPU_SANDY_BRIDGE_EP && cputype != CPU_IVY_BRIDGE_EPEX &&
+	    cputype != CPU_HASWELL_EPEX)
 		resolveaddr(m->addr);
 	if (!ascii_mode && ismemerr && (m->status & MCI_STATUS_ADDRV)) {
 		diskdb_resolve_addr(m->addr);
diff -urNp mcelog-d2e13bf0.orig/mcelog.h mcelog-d2e13bf0/mcelog.h
--- mcelog-d2e13bf0.orig/mcelog.h	2014-09-08 09:59:39.621699344 -0400
+++ mcelog-d2e13bf0/mcelog.h	2014-09-08 09:59:52.999327768 -0400
@@ -118,6 +118,7 @@ enum cputype {
 	CPU_IVY_BRIDGE, 
 	CPU_IVY_BRIDGE_EPEX, 
 	CPU_HASWELL,
+	CPU_HASWELL_EPEX,
 };
 
 enum option_ranges {
diff -urNp mcelog-d2e13bf0.orig/p4.c mcelog-d2e13bf0/p4.c
--- mcelog-d2e13bf0.orig/p4.c	2014-09-08 09:59:39.621699344 -0400
+++ mcelog-d2e13bf0/p4.c	2014-09-08 09:59:52.999327768 -0400
@@ -33,6 +33,7 @@
 #include "bitfield.h"
 #include "sandy-bridge.h"
 #include "ivy-bridge.h"
+#include "haswell.h"
 
 /* decode mce for P4/Xeon and Core2 family */
 
@@ -360,6 +361,9 @@ void decode_intel_mc(struct mce *log, in
 	case CPU_IVY_BRIDGE_EPEX:
 		ivb_decode_model(cputype, log->bank, log->status, log->misc);
 		break;
+	case CPU_HASWELL_EPEX:
+		hsw_decode_model(cputype, log->bank, log->status, log->misc);
+		break;
 	}
 
 	/* IO MCA - reported as bus/interconnect with specific PP,T,RRRR,II,LL values
diff -urNp mcelog-d2e13bf0.orig/sandy-bridge.c mcelog-d2e13bf0/sandy-bridge.c
--- mcelog-d2e13bf0.orig/sandy-bridge.c	2014-09-08 09:59:39.616699077 -0400
+++ mcelog-d2e13bf0/sandy-bridge.c	2014-09-08 09:59:56.033470497 -0400
@@ -63,18 +63,14 @@ static struct field pcu_mc4[] = {
 	{}
 };
 
-static char *memctrl_1[] = {
-	[0x001] = "Address parity error",
-	[0x002] = "HA Wrt buffer Data parity error",
-	[0x004] = "HA Wrt byte enable parity error",
-	[0x008] = "Corrected patrol scrub error",
-	[0x010] = "Uncorrected patrol scrub error",
-	[0x020] = "Corrected spare error",
-	[0x040] = "Uncorrected spare error",
-};
-
 static struct field memctrl_mc8[] = {
-	FIELD(16, memctrl_1),
+	SBITFIELD(16, "Address parity error"),
+	SBITFIELD(17, "HA Wrt buffer Data parity error"),
+	SBITFIELD(18, "HA Wrt byte enable parity error"),
+	SBITFIELD(19, "Corrected patrol scrub error"),
+	SBITFIELD(20, "Uncorrected patrol scrub error"),
+	SBITFIELD(21, "Corrected spare error"),
+	SBITFIELD(22, "Uncorrected spare error"),
 	{}
 };
 
